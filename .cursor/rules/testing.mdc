---
globs:
    - '**/*.test.ts'
    - '**/*.e2e.test.ts'
alwaysApply: true
---

**ESTRUTURE** testes unitários e de integração de forma clara, descritiva e focada, garantindo cobertura para cenários de sucesso e de erro.

## Princípios (Core)

- **ALWAYS** nomeie testes com a estrutura `should <comportamento esperado> if/when <condição>`.
    - Ex: `it('should return 400 if e-mail is already in use')`.
- **ALWAYS** organize testes em blocos `describe` aninhados para agrupar cenários relacionados (ex: `describe('error handling', ...)`).
- **ALWAYS** isole o "System Under Test" (SUT) usando mocks com `jest-mock-extended` para dependências injetadas.
- **NEVER** teste múltiplas responsabilidades em um único `it`. Cada teste deve ter um foco e uma asserção principal.
- **PREFER** asserções explícitas (`expect(result).toBe(...)`) a snapshots (`.toMatchSnapshot()`) para garantir clareza e evitar regressões acidentais.
- **PREFER** `it.each` para testar a mesma lógica com diferentes entradas (ex: validação de schema), evitando repetição de código.

## Estratégia de Mocking: A Regra de Ouro

- **Para Injeção de Dependência (DI): ALWAYS use `jest-mock-extended`**.
    - **O quê**: Services, Repositories, Adapters — qualquer classe injetada via construtor.
    - **Por quê**: Garante segurança de tipos máxima. Se a assinatura de um método na classe original mudar, o TypeScript quebrará o teste, prevenindo falsos positivos. É a abordagem mais robusta e de fácil manutenção.
    - **Como**: `const serviceMock = mock<MyService>()`.

- **Para Módulos Estáticos/Importados: PREFER `jest.mock`**.
    - **O quê**: Bibliotecas como `uuid`, `bcrypt`, SDKs externos ou helpers que são importados e usados diretamente, sem DI.
    - **Por quê**: É a ferramenta correta para substituir um módulo inteiro no escopo do teste.
    - **Como**: `jest.mock('uuid')`.

- **Manuais Stubs: AVOID**.
    - **Por quê**: São frágeis, verbosos e quebram facilmente com refatorações, como visto no caso do `DeleteUserController`. A abordagem com `jest-mock-extended` é superior em todos os aspectos para DI.

## Exemplos (do repositório)

### ✅ Correto

Um teste de controlador usando `jest-mock-extended` para injetar uma dependência de serviço mockada, garantindo segurança de tipos e isolamento.

```typescript
// Extraído de: src/controllers/users/delete-user.test.ts
import { mock, MockProxy } from 'jest-mock-extended'

describe('DeleteUserController', () => {
    let sut: DeleteUserController
    let deleteUserService: MockProxy<DeleteUserService> // Tipo seguro!

    beforeEach(() => {
        // Mock criado com segurança de tipos, sem stubs manuais.
        deleteUserService = mock<DeleteUserService>()
        sut = new DeleteUserController(deleteUserService)
    })

    describe('error handling', () => {
        it('should throw UserNotFoundError when service throws it', async () => {
            // arrange
            const error = new UserNotFoundError(userId)
            // O método 'execute' é tipado. Se a assinatura mudar, isto quebrará.
            deleteUserService.execute.mockRejectedValue(error)

            // act & assert
            await expect(sut.execute(baseHttpRequest)).rejects.toThrow(error)
        })
    })

    describe('success', () => {
        it('should return 200 if user is deleted successfully', async () => {
            // arrange
            deleteUserService.execute.mockResolvedValueOnce(
                deleteUserRepositoryResponse,
            )
            // act
            const response = await sut.execute(baseHttpRequest)

            // assert
            expect(response.statusCode).toBe(200)
        })
    })
})
```

### Testes E2E: Factories para Setup

#### ✅ Correto

Usar uma factory para criar dados pré-requisito (ex: criar um usuário para poder testar a rota de deleção). Isso isola o teste à funcionalidade que está sendo validada.

```typescript
// Extraído de: src/routes/users.e2e.test.ts
describe('DELETE /api/users/me', () => {
    it('should return 200 when user is deleted', async () => {
        // arrange: setup com factory
        const user = await makeUser()

        // act: testa a rota de deleção
        const { body: responseBody } = await request(app)
            .delete(`/api/users/me`)
            .set('authorization', `Bearer ${user.tokens.accessToken}`)
            .expect(200)

        // assert
        expect(responseBody.message).toBe(ResponseMessage.USER_DELETED)
    })
})
```

## Escopo & Particularidades

- **Aplica-se a**: Todos os arquivos de teste (`.test.ts`, `.e2e.test.ts`).
- **Não se aplica a**: Lógica de setup de testes (ex: `jest.global-setup.ts`).
- **Particularidades**:
    - **Testes Unitários (Controllers, Services, Adapters)**: Foco em isolamento total com mocks (`jest-mock-extended` ou `jest.mock`).
    - **Testes de Integração (Repositories)**: Interação com o banco de dados de teste, sem mocks para o Prisma Client.
    - **Testes E2E (Routes)**: Simulam requisições HTTP reais.
        - **PREFER** usar _factories_ (`src/test/factories/`) para criar o estado necessário para um teste.
        - **NEVER** use _factories_ para testar a própria lógica de criação (ex: a rota `POST /users`).
