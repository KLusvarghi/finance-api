---
globs: ['*.test.ts', '*.spec.ts', '*.e2e.test.ts']
alwaysApply: true
---

**ESTRUTURE** testes unitários e de integração de forma clara, descritiva e focada, garantindo cobertura para cenários de sucesso e de erro.

## Princípios (Core)

- **ALWAYS** nomeie testes com a estrutura `should <comportamento esperado> if/when <condição>`.
    - Ex: `it('should return 400 if e-mail is already in use')`.
- **ALWAYS** organize testes em blocos `describe` aninhados para agrupar cenários relacionados (ex: `describe('error handling', ...)`).
- **ALWAYS** isole o "System Under Test" (SUT) usando mocks ou stubs para suas dependências em testes unitários.
- **NEVER** teste múltiplas responsabilidades em um único `it`. Cada teste deve ter um foco e uma asserção principal.
- **PREFER** asserções explícitas (`expect(result).toBe(...)`) a snapshots (`.toMatchSnapshot()`) para garantir clareza e evitar regressões acidentais.
- **PREFER** `it.each` para testar a mesma lógica com diferentes entradas (ex: validação de schema), evitando repetição de código.

## Exemplos (do repositório)

### ✅ Correto

Um teste de serviço bem estruturado, com nomes descritivos e mocks claros para isolar a unidade.

```typescript
// Extraído de: src/services/users/create-user.test.ts
describe('CreateUserService', () => {
    // ... setup com stubs para repositórios e adapters ...

    describe('error handling', () => {
        it('should throw an EmailAlreadyExistsError if getUserByEmailRepository returns a user', () => {
            // arrange
            jest.spyOn(
                getUserByEmailRepository,
                'execute',
            ).mockResolvedValueOnce(createUserRepositoryResponse)

            // act
            const promise = sut.execute(createUserParams)

            // assert
            expect(promise).rejects.toThrow(
                new EmailAlreadyExistsError(createUserParams.email),
            )
        })
    })

    describe('success', () => {
        it('should create a user successfully', async () => {
            // act
            const response = await sut.execute(createUserParams)

            // assert
            expect(response).toEqual(createUserServiceResponse)
        })
    })
})
```

### ❌ Evitar

Testes de validação de schema repetitivos que podem ser consolidados com `it.each`.

```typescript
// Extraído de: src/controllers/users/create-user.test.ts
describe('validations', () => {
    describe('firstName', () => {
        it('should return 400 if firstName is not provided', async () => {
            // arrange
            const response = await sut.execute({
                body: { ...params, firstName: undefined },
            })
            // assert
            expect(response.statusCode).toBe(400)
        })
    })

    describe('lastName', () => {
        it('should return 400 if lastName is not provided', async () => {
            // arrange
            const response = await sut.execute({
                body: { ...params, lastName: undefined },
            })
            // assert
            expect(response.statusCode).toBe(400)
        })
    })

    // ... mais testes repetitivos para email e password ...
})
```

### Testes E2E: Factories para Setup

#### ✅ Correto

Usar uma factory para criar dados pré-requisito (ex: criar um usuário para poder testar a rota de deleção). Isso isola o teste à funcionalidade que está sendo validada.

```typescript
// Extraído de: src/routes/users.e2e.test.ts
describe('DELETE /api/users/me', () => {
    it('should return 200 when user is deleted', async () => {
        // arrange: setup com factory
        const user = await makeUser()

        // act: testa a rota de deleção
        const { body: responseBody } = await request(app)
            .delete(`/api/users/me`)
            .set('authorization', `Bearer ${user.tokens.accessToken}`)
            .expect(200)

        // assert
        expect(responseBody.message).toBe(ResponseMessage.USER_DELETED)
    })
})
```

#### ❌ Evitar

Não usar uma factory para testar a própria funcionalidade de criação. A rota de criação deve ser testada diretamente para validar todo o fluxo (controller, serviço, etc.).

```typescript
// Extraído de: src/routes/users.e2e.test.ts
describe('POST /api/users', () => {
    it('should return 201 when user is created', async () => {
        // act & assert: testa a rota de criação diretamente
        const { body: responseBody } = await request(app)
            .post('/api/users')
            .send(createUserParams)
            .expect(201)

        expect(responseBody.data.tokens.accessToken).toBeDefined()
        expect(responseBody.message).toBe(ResponseMessage.USER_CREATED)
    })
})
```

## Escopo & Particularidades

- **Aplica-se a**: Todos os arquivos de teste (`.test.ts`, `.e2e.test.ts`).
- **Não se aplica a**: Lógica de setup de testes (ex: `jest.global-setup.ts`).
- **Particularidades**:
    - **Testes Unitários (Serviços, Adapters)**: Foco em isolamento total com mocks/stubs.
    - **Testes de Integração (Controllers, Repositories)**: Interação com stubs de serviços e/ou banco de dados de teste.
    - **Testes E2E (Routes)**: Simulam requisições HTTP reais e verificam a resposta de ponta a ponta.
        - **PREFER** usar _factories_ (localizadas em `src/test/factories/`) para criar o estado necessário para um teste (ex: criar um usuário antes de testar a rota de deleção). Isso evita chamadas de API desnecessárias e torna os testes mais rápidos e focados.
        - **NEVER** use _factories_ para testar a própria lógica de criação. O SUT (System Under Test) deve ser exercitado através da requisição HTTP (`supertest`). Se uma _factory_ necessária não existir, ela deve ser criada.

## Referências

- `build-improve-rules.mdc`
