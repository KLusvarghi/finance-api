---
globs: ['*.test.ts', '*.spec.ts', '*.e2e.test.ts']
alwaysApply: true
---

**ESTRUTURE** testes unitários e de integração de forma clara, descritiva e focada, garantindo cobertura para cenários de sucesso e de erro.

## Princípios (Core)

- **ALWAYS** nomeie testes com a estrutura `should <comportamento esperado> if/when <condição>`.
    - Ex: `it('should return 400 if e-mail is already in use')`.
- **ALWAYS** organize testes em blocos `describe` aninhados para agrupar cenários relacionados (ex: `describe('error handling', ...)`).
- **ALWAYS** isole o "System Under Test" (SUT) usando mocks ou stubs para suas dependências em testes unitários.
- **NEVER** teste múltiplas responsabilidades em um único `it`. Cada teste deve ter um foco e uma asserção principal.
- **PREFER** asserções explícitas (`expect(result).toBe(...)`) a snapshots (`.toMatchSnapshot()`) para garantir clareza e evitar regressões acidentais.
- **PREFER** `it.each` para testar a mesma lógica com diferentes entradas (ex: validação de schema), evitando repetição de código.

## Exemplos (do repositório)

### ✅ Correto

Um teste de serviço bem estruturado, com nomes descritivos e mocks claros para isolar a unidade.

```typescript
// Extraído de: src/services/users/create-user.test.ts
describe('CreateUserService', () => {
    // ... setup com stubs para repositórios e adapters ...

    describe('error handling', () => {
        it('should throw an EmailAlreadyExistsError if getUserByEmailRepository returns a user', () => {
            // arrange
            jest.spyOn(
                getUserByEmailRepository,
                'execute',
            ).mockResolvedValueOnce(createUserRepositoryResponse)

            // act
            const promise = sut.execute(createUserParams)

            // assert
            expect(promise).rejects.toThrow(
                new EmailAlreadyExistsError(createUserParams.email),
            )
        })
    })

    describe('success', () => {
        it('should create a user successfully', async () => {
            // act
            const response = await sut.execute(createUserParams)

            // assert
            expect(response).toEqual(createUserServiceResponse)
        })
    })
})
```

### ❌ Evitar

Testes de validação de schema repetitivos que podem ser consolidados com `it.each`.

```typescript
// Extraído de: src/controllers/users/create-user.test.ts
describe('validations', () => {
    describe('first_name', () => {
        it('should return 400 if first_name is not provided', async () => {
            // arrange
            const response = await sut.execute({
                body: { ...params, first_name: undefined },
            })
            // assert
            expect(response.statusCode).toBe(400)
        })
    })

    describe('last_name', () => {
        it('should return 400 if last_name is not provided', async () => {
            // arrange
            const response = await sut.execute({
                body: { ...params, last_name: undefined },
            })
            // assert
            expect(response.statusCode).toBe(400)
        })
    })

    // ... mais testes repetitivos para email e password ...
})
```

## Escopo & Particularidades

- **Aplica-se a**: Todos os arquivos de teste (`.test.ts`, `.e2e.test.ts`).
- **Não se aplica a**: Lógica de setup de testes (ex: `jest.global-setup.ts`).
- **Particularidades**:
    - **Testes Unitários (Serviços, Adapters)**: Foco em isolamento total com mocks/stubs.
    - **Testes de Integração (Controllers, Repositories)**: Interação com stubs de serviços e/ou banco de dados de teste.
    - **Testes E2E (Routes)**: Simulam requisições HTTP reais e verificam a resposta de ponta a ponta.

## Referências

- `build-improve-rules.mdc`
