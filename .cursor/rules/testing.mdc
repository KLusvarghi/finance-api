---
globs:
    - '**/*.test.ts'
    - '**/*.e2e.test.ts'
alwaysApply: true
---

**ESTRUTURE** testes unitários e de integração de forma clara, descritiva e focada, garantindo cobertura para cenários de sucesso e de erro.

## Princípios (Core)

- **ALWAYS** nomeie testes com a estrutura `should <comportamento esperado> if/when <condição>`.
    - Ex: `it('should return 400 if e-mail is already in use')`.
- **ALWAYS** organize testes em blocos `describe` aninhados para agrupar cenários relacionados (ex: `describe('error handling', ...)`).
- **ALWAYS** isole o "System Under Test" (SUT) usando mocks com `jest-mock-extended` para dependências injetadas.
- **ALWAYS** utilize `beforeEach` para configurar um cenário de sucesso padrão ("happy path"). Isso centraliza o `arrange` comum, mantém os testes DRY e permite que cada `it` se concentre em sobrescrever apenas os mocks necessários para seu caso específico.
- **NEVER** teste múltiplas responsabilidades em um único `it`. Cada teste deve ter um foco e uma asserção principal.
- **PREFER** asserções explícitas (`expect(result).toBe(...)`) a snapshots (`.toMatchSnapshot()`) para garantir clareza e evitar regressões acidentais.
- **PREFER** `it.each` para testar a mesma lógica com diferentes entradas (ex: validação de schema), evitando repetição de código.

## Estratégia de Mocking: A Regra de Ouro

- **Para Injeção de Dependência (DI): ALWAYS use `jest-mock-extended`**.
    - **O quê**: Services, Repositories, Adapters — qualquer classe injetada via construtor.
    - **Por quê**: Garante segurança de tipos máxima. Se a assinatura de um método na classe original mudar, o TypeScript quebrará o teste, prevenindo falsos positivos. É a abordagem mais robusta e de fácil manutenção.
    - **Como**: `const serviceMock = mock<MyService>()`.

- **Para Módulos Estáticos/Importados: PREFER `jest.mock`**.
    - **O quê**: Bibliotecas como `uuid`, `bcrypt`, SDKs externos ou helpers que são importados e usados diretamente, sem DI.
    - **Por quê**: É a ferramenta correta para substituir um módulo inteiro no escopo do teste.
    - **Como**: `jest.mock('uuid')`.

- **Manuais Stubs: AVOID**.
    - **Por quê**: São frágeis, verbosos e quebram facilmente com refatorações, como visto no caso do `DeleteUserController`. A abordagem com `jest-mock-extended` é superior em todos os aspectos para DI.

## Exemplos (do repositório)

### ✅ Correto (Isolamento Básico)

Um teste de controlador usando `jest-mock-extended` para injetar uma dependência de serviço mockada, garantindo segurança de tipos e isolamento.

```typescript
// Extraído de: src/controllers/users/delete-user.test.ts
import { mock, MockProxy } from 'jest-mock-extended'

describe('DeleteUserController', () => {
    let sut: DeleteUserController
    let deleteUserService: MockProxy<DeleteUserService> // Tipo seguro!

    beforeEach(() => {
        // Mock criado com segurança de tipos, sem stubs manuais.
        deleteUserService = mock<DeleteUserService>()
        sut = new DeleteUserController(deleteUserService)
    })

    describe('error handling', () => {
        it('should throw UserNotFoundError when service throws it', async () => {
            // arrange
            const error = new UserNotFoundError(userId)
            // O método 'execute' é tipado. Se a assinatura mudar, isto quebrará.
            deleteUserService.execute.mockRejectedValue(error)

            // act & assert
            await expect(sut.execute(baseHttpRequest)).rejects.toThrow(error)
        })
    })

    describe('success', () => {
        it('should return 200 if user is deleted successfully', async () => {
            // arrange
            deleteUserService.execute.mockResolvedValueOnce(
                deleteUserRepositoryResponse,
            )
            // act
            const response = await sut.execute(baseHttpRequest)

            // assert
            expect(response.statusCode).toBe(200)
        })
    })
})
```

### ✅ Correto (com `beforeEach` para DRY)

Use `beforeEach` para definir o estado padrão dos mocks (geralmente o "caminho feliz"). Testes individuais devem então sobrescrever apenas o necessário para testar seus cenários específicos, tornando o código mais limpo e focado.

```typescript
// Baseado em: src/services/users/update-user.test.ts
describe('UpdateUserService', () => {
    let sut: UpdateUserService
    let getUserByIdRepository: MockProxy<PostgresGetUserByIdRepository>
    let getUserByEmailRepository: MockProxy<PostgresGetUserByEmailRepository>
    // ... outros mocks

    beforeEach(() => {
        // Inicialização de todos os mocks
        getUserByIdRepository = mock<PostgresGetUserByIdRepository>()
        getUserByEmailRepository = mock<PostgresGetUserByEmailRepository>()
        // ...

        sut = new UpdateUserService(...)

        // SETUP PADRÃO (HAPPY PATH)
        // Por padrão, todo teste assume que o usuário existe, o email não está em uso, etc.
        getUserByIdRepository.execute.mockResolvedValue(updateUserRepositoryResponse)
        getUserByEmailRepository.execute.mockResolvedValue(null) // Email não está em uso
        updateUserRepository.execute.mockResolvedValue(updateUserRepositoryResponse)
        passwordHasherAdapter.execute.mockResolvedValue('valid_hash')
    })

    describe('success', () => {
        it('should update a user successfully', async () => {
            // arrange: Já foi feito no beforeEach!

            // act
            const response = await sut.execute(userId, updateUserParams)

            // assert
            expect(response).toEqual(updateUserServiceResponse)
        })
    })

    describe('error handling', () => {
        it('should throw UserNotFoundError if user is not found', async () => {
            // arrange: Sobrescreve apenas o mock necessário para este cenário
            getUserByIdRepository.execute.mockResolvedValue(null)

            // act & assert
            await expect(sut.execute(userId, updateUserParams)).rejects.toThrow(
                UserNotFoundError,
            )
        })

        it('should throw EmailAlreadyExistsError if email is already in use', async () => {
            // arrange: Sobrescreve apenas o mock necessário para este cenário
            getUserByEmailRepository.execute.mockResolvedValue(updateUserRepositoryResponse)

            // act & assert
            await expect(sut.execute('different-user-id', { email: 'test@test.com' })).rejects.toThrow(
                EmailAlreadyExistsError,
            )
        })
    })
})
```

### Testes E2E: Factories para Setup

#### ✅ Correto

Usar uma factory para criar dados pré-requisito (ex: criar um usuário para poder testar a rota de deleção). Isso isola o teste à funcionalidade que está sendo validada.

```typescript
// Extraído de: src/routes/users.e2e.test.ts
describe('DELETE /api/users/me', () => {
    it('should return 200 when user is deleted', async () => {
        // arrange: setup com factory
        const user = await makeUser()

        // act: testa a rota de deleção
        const { body: responseBody } = await request(app)
            .delete(`/api/users/me`)
            .set('authorization', `Bearer ${user.tokens.accessToken}`)
            .expect(200)

        // assert
        expect(responseBody.message).toBe(ResponseMessage.USER_DELETED)
    })
})
```

## Escopo & Particularidades

- **Aplica-se a**: Todos os arquivos de teste (`.test.ts`, `.e2e.test.ts`).
- **Não se aplica a**: Lógica de setup de testes (ex: `jest.global-setup.ts`).
- **Particularidades**:
    - **Testes Unitários (Controllers, Services, Adapters)**: Foco em isolamento total com mocks (`jest-mock-extended` ou `jest.mock`).
    - **Testes de Integração (Repositories)**: Interação com o banco de dados de teste, sem mocks para o Prisma Client.
    - **Testes E2E (Routes)**: Simulam requisições HTTP reais.
        - **PREFER** usar _factories_ (`src/test/factories/`) para criar o estado necessário para um teste.
        - **NEVER** use _factories_ para testar a própria lógica de criação (ex: a rota `POST /users`).
