---
globs: ['src/controllers/**/*.ts', '!src/controllers/**/*.test.ts']
alwaysApply: true
---

**PADRONIZE** a estrutura de controladores para seguir o fluxo `validar > executar > responder`, utilizando helpers para validação e respostas HTTP.

## Princípios (Core)

- **ALWAYS** implemente a interface `Controller` para garantir a assinatura do método `execute`.
- **ALWAYS** valide o `body` e os `params` da requisição usando um schema Zod (`.parseAsync()`) como primeira ação dentro de um bloco `try...catch`.
- **ALWAYS** chame o serviço correspondente apenas após a validação ter sido bem-sucedida.
- **ALWAYS** utilize os helpers de resposta HTTP (ex: `ok`, `created`, `badRequest`, `serverError`) para formatar todas as saídas.
- **NEVER** retorne erros genéricos. O bloco `catch` **MUST** tratar `ZodError` e erros de negócio específicos (ex: `EmailAlreadyExistsError`) de forma distinta.

## Exemplos (do repositório)

### ✅ Correto

Um controlador com fluxo claro de validação, execução e tratamento de erro específico.

```typescript
// Extraído de: src/controllers/users/create-user.ts
export class CreateUserController
    implements Controller<CreateUserParams, UserPublicResponse>
{
    // ... constructor ...

    async execute(
        httpRequest: HttpRequest,
    ): Promise<HttpResponse<UserPublicResponse>> {
        try {
            await createUserSchema.parseAsync(httpRequest.body)

            const createdUser = await this.createUserService.execute(
                httpRequest.body,
            )

            return created(createdUser, ResponseMessage.USER_CREATED)
        } catch (error) {
            if (error instanceof ZodError) {
                return handleZodValidationError(error)
            }

            if (error instanceof EmailAlreadyExistsError) {
                return emailAlreadyExistsResponse(error.message)
            }

            console.error(error)
            return serverError()
        }
    }
}
```

### ❌ Evitar (Refatoração Sugerida)

Lógica de validação Zod misturada diretamente no corpo do controlador. A validação pode ser encapsulada em um helper para simplificar o `try...catch`.

```typescript
// Padrão atual em: src/controllers/users/create-user.ts
// ...
        try {
            // Validação acoplada
            const params = httpRequest.body
            await createUserSchema.parseAsync(params as CreateUserParams)

            const createdUser = await this.createUserService.execute(
                params as CreateUserParams,
            )
// ...

// Sugestão de melhoria com um helper de validação:
        try {
            const params = await validate(createUserSchema, httpRequest.body);

            const createdUser = await this.createUserService.execute(params);

            return created(createdUser, ResponseMessage.USER_CREATED);
        } catch (error) {
            // ... catch block fica mais focado nos erros de negócio
        }
```

## Escopo & Particularidades

- **Aplica-se a**: Todos os arquivos de controladores dentro de `src/controllers`, exceto os arquivos de teste.
- **Particularidades**:
    - A validação deve ocorrer antes de qualquer outra lógica de negócio.
    - O uso dos helpers em `src/controllers/_helpers` é mandatório para manter a consistência das respostas da API.

## Referências

- `build-improve-rules.mdc`
- `testing.mdc`
