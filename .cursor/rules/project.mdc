---
globs: 'src/**/*.ts'
alwaysApply: true
---

**ESTABELEÇA** as convenções e padrões fundamentais do projeto e **GUIE** a IA na execução de tarefas de forma planejada.

## Princípios Fundamentais

- **ALWAYS** escrever código **e comentários** em **Inglês**.
- **ALWAYS** seguir **Clean Architecture**: `Controllers` → `Services` → `Repositories`.
- **ALWAYS** aplicar os princípios **SOLID** e **DRY**.
- **NEVER** acessar o banco de dados diretamente nos controllers – use **Repositories**.
- **NEVER** usar o tipo `any` – utilize tipos precisos ou **Zod**.
- **ALWAYS** usar helpers centralizados para respostas HTTP, erros e logs.

---

## Arquitetura & Injeção de Dependência (Arquitetura Hexagonal)

- **ALWAYS** utilize a **Arquitetura Hexagonal** (Ports & Adapters) para garantir o desacoplamento e a testabilidade.
- **ALWAYS** implemente a **Injeção de Dependência (DI)** via construtor. As classes (Controllers, Services) **NUNCA** devem instanciar suas dependências diretamente (ex: `new MyService()`), mas sim recebê-las prontas.
- **PREFER** que `Controllers` recebam `Services`.
- **PREFER** que `Services` recebam `Repositories` e `Adapters`.
- **NEVER** um `Controller` deve injetar um `Repository` ou `Adapter` diretamente.

### ✅ Correto (Injeção de Dependência)

**Controller injetando Service:**

```typescript
// Extraído de: src/controllers/users/create-user.ts
export class CreateUserController
    implements Controller<CreateUserParams, UserPublicResponse>
{
    constructor(private readonly createUserService: CreateUserService) {}
    // ... execute method ...
}
```

**Service injetando Repository:**

```typescript
// Extraído de: src/services/users/delete-user.ts
export class DeleteUserService implements IDeleteUserService {
    constructor(private readonly deletedUserRepository: DeleteUserRepository) {}
    // ... execute method ...
}
```

**Service injetando Adapter:**

```typescript
// Extraído de: src/services/users/create-user.ts
export class CreateUserService implements ICreateUserService {
    constructor(
        private readonly createUserRepository: CreateUserRepository,
        private readonly passwordHasher: PasswordHasherAdapter,
        // ... outras dependências ...
    ) {}
    // ... execute method ...
}
```

---

## Stack de Tecnologia & Escopo

- **Node.js** v20+
- **Framework**: Express 5
- **Linguagem**: TypeScript (modo **strict** obrigatório)
- **ORM**: Prisma / PostgreSQL
- **Validação**: Zod
- **Testes**: Jest
- **Ferramentas**: ESLint, Prettier, Husky
- **Módulos**: **ES Modules**
- **Escopo**: API Financeira B2B/B2C.

---

## Estrutura de Diretórios

- `src/controllers` – parsing, validação e chamadas de serviço.
- `src/services` – **toda** lógica de negócio.
- `src/repositories` – acesso ao banco via Prisma.
- `src/adapters` – integrações externas (hashing, fila, etc.).
- `src/schemas` – definições **Zod**.
- `src/shared` – helpers (HTTP, logger, tipos globais).

---

## Convenções de Nomeação

- **Variáveis/Funções**: `camelCase`
- **Classes/Interfaces/Tipos**: `PascalCase`
- **Arquivos**: `kebab-case` (`user-service.ts`)
- **Aliases**: `@/*` no `tsconfig.json`.
- **Exports**: **named exports** (evite `default`).
- **Arquivos `index.ts`**: apenas re-exports – **NUNCA** lógica.

---

## Pipeline Proativo de Execução de Tarefas

1. **ALWAYS** criar checklist com a ferramenta `todo` antes de codar.
2. **ALWAYS** começar por schemas **Zod** (contrato primeiro) e derivar `z.infer`.
3. **ALWAYS** implementar uma responsabilidade de cada vez (SRP).
4. **ALWAYS** marcar a tarefa como `completed` e rodar o linter ao finalizar.

---

## Padrões de Projeto

### Padrões de Resposta (HTTP)

- **ALWAYS** use os helpers (`ok`, `created`, etc.) para garantir um envelope de resposta padronizado.
- **ALWAYS** estruture todas as respostas com um envelope JSON consistente para previsibilidade no front-end.

#### ✅ Estrutura de Sucesso (Status `2xx`)

- **ALWAYS** inclua `success: true` e uma `message` descritiva.
- **PREFER** omitir a chave `data` se não houver conteúdo a ser retornado (ex: em operações de `DELETE`).

**Exemplo: Sucesso com dados (e.g., `POST /users`)**

```json
// Status: 201 Created
{
    "success": true,
    "message": "User created successfully.",
    "data": {
        "id": "user-123",
        "firstName": "John",
        "email": "john.doe@email.com"
    }
}
```

**Exemplo: Sucesso sem dados (e.g., `DELETE /transactions/tx-456`)**

```json
// Status: 200 OK
{
    "success": true,
    "message": "Transaction deleted successfully."
}
```

---

### Tratamento de Erros e Estrutura de Resposta

- **ALWAYS** lance erros customizados que estendem a classe `Error` a partir dos `Services` (ex: `EmailAlreadyExistsError`).
- **ALWAYS** capture os erros nos `Controllers` e use os helpers HTTP (ex: `badRequest`, `notFound`) para formatar a resposta de erro padronizada.
- **NEVER** exponha stack traces ou mensagens de erro internas na resposta da API. Logue-os internamente.

#### ✅ Estrutura de Erro (Status `4xx`, `5xx`)

- **ALWAYS** inclua `success: false`, uma `message` clara para o usuário e um `code` para consumo da lógica do client.
- **PREFER** usar a chave `details` para enviar contexto adicional de debugging (ex: ID da entidade, erros de validação por campo). O conteúdo de `details` **NÃO** deve ser usado para lógica no front-end.
- **PREFER** omitir a chave `details` se não houver contexto adicional.

**Exemplo: Erro de Validação (e.g., `POST /users` com email inválido)**

```json
// Status: 400 Bad Request
{
    "success": false,
    "message": "Invalid input provided.",
    "code": "VALIDATION_ERROR",
    "details": {
        "email": "Must be a valid email address."
    }
}
```

**Exemplo: Recurso não encontrado (e.g., `GET /transactions/tx-inexistente`)**

```json
// Status: 404 Not Found
{
    "success": false,
    "message": "Transaction not found.",
    "code": "TRANSACTION_NOT_FOUND",
    "details": {
        "transactionId": "tx-inexistente"
    }
}
```

**Exemplo de fluxo (Service -> Controller):**

```ts
// Em um Service:
if (userExists) {
    throw new EmailAlreadyExistsError(email);
}

// Em um Controller:
// ...
} catch (error) {
    if (error instanceof EmailAlreadyExistsError) {
        return badRequest(
            error.message,
            'EMAIL_ALREADY_EXISTS', // code
            { email: error.email }  // details
        );
    }
    // ...
    return serverError();
}
```

### Paginação & Ordenação

- Parâmetros: `page`, `limit`, `sortBy`, `order` (`asc` | `desc`).
- Defaults: `page=1`, `limit=20`.
- **ALWAYS** validar com Zod.

---

## Logging

- **MUST** usar logger centralizado.
- **ALWAYS** logar `method`, `path`, `userId`, `duration`.
- **ALWAYS** registrar stack trace em logs internos.

---

## Formatação & Lint

- **ALWAYS** usar Prettier + ESLint.
- **ALWAYS** preferir early return para evitar aninhamento profundo.
- Código **MUST** passar nos hooks do Husky.

---

## Exemplos

### ✅ Correto

```ts
// user.service.ts
export class UserService {
    constructor(private readonly userRepository: UserRepository) {}

    async create(params: CreateUserDTO): Promise<UserProfileDTO> {
        const user = await this.userRepository.create(params)
        return mapUserToProfileDTO(user) // não vaza modelo Prisma
    }
}
```

### ❌ Evitar

```ts
// user.controller.ts
const user = await prisma.user.create(req.body) // acesso direto + vazamento de modelo
return res.json(user) // resposta sem DTO, sem helper
```

---

## Referências

- `typescript.mdc`
- `testing.mdc`
- `controllers-standard.mdc`
- `build-improve-rules.mdc`
