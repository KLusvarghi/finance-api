---
globs: ['src/**/*.ts']
alwaysApply: true
---

**ESTABELEÇA** um padrão de código TypeScript robusto e consistente para o back-end, focando em clareza, segurança de tipos e manutenibilidade, e **GUIE** a IA na execução de tarefas de forma planejada.

## Pipeline Proativo de Execução de Tarefas

### Como a IA deve abordar tarefas de codificação TypeScript

1.  **Análise e Decomposição (Planejamento)**
    - **ALWAYS** quebre a solicitação do usuário em um checklist de tarefas usando a ferramenta de `todo`.
    - **ALWAYS** identifique todos os arquivos que serão criados ou modificados.
    - **PREFER** criar tarefas granulares. Ex: "Criar schema Zod para usuário" em vez de "Implementar criação de usuário".

2.  **Definição de Contratos Primeiro (Schema-First)**
    - **ALWAYS** inicie a implementação pela definição dos schemas Zod para DTOs e validações.
    - **ALWAYS** derive os tipos TypeScript a partir dos schemas com `z.infer`. Isso garante que o contrato de dados guie a implementação.

3.  **Implementação Focada (SRP)**
    - **ALWAYS** implemente uma responsabilidade por vez, seguindo a lista de tarefas.
    - **ALWAYS** aplique os princípios de código desta `RULE` durante a escrita (imutabilidade, `private`/`readonly`, etc.).
    - **NEVER** vaze tipos do Prisma nas respostas da API. Crie DTOs e mapeadores para separar as camadas.

4.  **Validação e Finalização**
    - **ALWAYS** ao concluir uma tarefa, marque-a como `completed`.
    - **PREFER** usar a ferramenta de linter nos arquivos modificados para garantir que não há erros de tipo ou lint.
    - **NEVER** submeta código com o tipo `any` explícito ou implícito.

---

## 1. Async/Await

### Princípios (Core)

- **ALWAYS** utilize `async/await` para código assíncrono.
- **AVOID** encadear `.then()` para controle de fluxo.
- **ALWAYS** tipe os retornos de função como `Promise<T>`.

### Exemplos

**✅ Correto:**

```typescript
const fetchUserData = async (id: string): Promise<User> => {
    const res = await fetch(`/api/users/${id}`)
    return await res.json()
}
```

**❌ Evitar:**

```typescript
fetch(`/api/users/${id}`)
    .then((res) => res.json())
    .then(callback)
```

---

## 2. Declarações de Variáveis

### Princípios (Core)

- **ALWAYS** use `const` como padrão.
- **USE** `let` apenas quando uma variável precisar ser reatribuída.
- **NEVER** utilize `var`.

### Exemplos

**✅ Correto:**

```typescript
const users = ['Alice', 'Bob']
let currentIndex = 0
```

**❌ Evitar:**

```typescript
var users = ['Alice', 'Bob']
```

---

## 3. Classes

### Princípios (Core)

- **PREFER** que as propriedades da classe sejam `private` ou `protected`.
- **USE** `readonly` para propriedades que não são modificadas após a inicialização.
- **AVOID** expor detalhes de implementação interna.

### Exemplos

**✅ Correto:**

```typescript
class UserService {
    private readonly userRepository: UserRepository
    protected logger: Logger

    constructor(userRepository: UserRepository, logger: Logger) {
        this.userRepository = userRepository
        this.logger = logger
    }
}
```

**❌ Evitar:**

```typescript
class UserService {
    // Propriedades são implicitamente públicas, expondo detalhes da implementação.
    userRepository: UserRepository
    logger: Logger
}
```

---

## 4. Manipulação de Arrays

### Princípios (Core)

- **PREFER** métodos funcionais como `map`, `filter`, e `reduce` para transformação de dados.
- **AVOID** laços `for` manuais para tarefas que podem ser feitas funcionalmente.
- **PREFER** operações imutáveis que retornam novos arrays em vez de modificar o original.

### Exemplos

**✅ Correto:**

```typescript
const activeUsers = users.filter((u) => u.isActive)
const userNames = users.map((u) => u.name)
```

**❌ Evitar:**

```typescript
const active = []
for (let i = 0; i < users.length; i++) {
    if (users[i].isActive) {
        active.push(users[i])
    }
}
```

---

## 5. Imports & Exports

### Princípios (Core)

- **ALWAYS** use **ES Modules** (`import`/`export`).
- **PREFER** exportações nomeadas para facilitar o tree-shaking e ter dependências mais claras.
- **AVOID** exportações padrão (`export default`).

### Exemplos

**✅ Correto:**

```typescript
export class UserService {
    /* ... */
}
export function formatCurrency(value: number) {
    /* ... */
}
```

**❌ Evitar:**

```typescript
export default class UserService {
    /* ... */
}
```

---

## 6. DTOs & Schemas

### Princípios (Core)

- **ALWAYS** use `z.infer` para derivar tipos TypeScript a partir de schemas **Zod**.
- **ALWAYS** valide todas as entradas externas (ex: corpo de requisições da API) com um schema.
- **ALWAYS** defina contratos de dados claros para entradas e saídas.

### Exemplos

**✅ Correto:**

```typescript
import { z } from 'zod'

const CreateUserSchema = z.object({
    name: z.string().min(1),
    email: z.string().email(),
})

type CreateUserDTO = z.infer<typeof CreateUserSchema>
```

---

## 7. Arquitetura & Convenções

### Princípios (Core)

- **ALWAYS** siga o **Princípio da Responsabilidade Única** (SRP): um arquivo deve ter um propósito principal.
- **ALWAYS** use sufixos descritivos para arquivos (ex: `.service.ts`, `.controller.ts`, `.schema.ts`).
- **NEVER** vaze tipos de modelo do **Prisma** diretamente nas respostas da API. Use DTOs em seu lugar.

### Exemplos

**❌ Evitar (Vazando Modelo Prisma):**

```typescript
// Em um controlador
const user = await userService.findById(id)
// Isso vaza o modelo User completo, que pode incluir dados sensíveis como hashes de senha.
return res.json(user)
```

**✅ Correto (Usando um DTO):**

```typescript
// user.dto.ts
export class UserProfileDTO {
    id: string
    firstName: string
    email: string
}

// Em um controlador
const user = await userService.findById(id)
// Uma função de mapeamento transforma o modelo Prisma em um DTO seguro.
const userProfile = mapUserToProfileDTO(user)
return res.json(userProfile)
```

---

## 8. Tratamento de Erros

### Princípios (Core)

- **ALWAYS** use classes de erro personalizadas que estendem `Error` para erros específicos da aplicação.
- **NEVER** exponha erros brutos de banco de dados ou internos para o cliente.
- **ALWAYS** defina um formato de resposta de erro consistente.

### Exemplos

**✅ Correto:**

```typescript
class AppError extends Error {
    constructor(
        public readonly message: string,
        public readonly statusCode: number = 400,
        public readonly code?: string,
    ) {
        super(message)
    }
}

// Uso em um serviço
if (!user) {
    throw new AppError('User not found', 404, 'USER_NOT_FOUND')
}
```
